â›“ï¸ Onchain Governance Marathon â€” with Haskell Chapters
This marathon is a practical journey through key Haskell programming concepts, using the real-world challenge of building an onchain-style decentralized governance system (DAO).

ğŸ Project Goal
Design a lightweight DAO voting engine that includes:

âœ… Proposal creation

ğŸ—³ï¸ Voting (Yes/No) per proposal

â° Deadline enforcement

âŒ Rejection of late votes

âš–ï¸ Execution logic based on majority

ğŸ“˜ Haskell Chapters Covered
Each stage of the marathon introduces a new Haskell topic:

Introduction to Haskell
Basic syntax, GHC, and first programs

Types and type annotations

Functions and expressions

Pure Functions
No side effects

Same input â†’ same output

Essential for predictable DAO logic

Pattern Matching
Match on data like Yes / No

Elegant control over vote handling

Algebraic Data Types (ADTs)
Define custom types like Proposal, Vote, Result

Use data and newtype effectively

Guards and Conditionals
Choose outcomes based on vote counts or time

Write clear decision logic for proposal results

Polymorphism and Type Classes
Reusable logic across types

Use of Eq, Show, and custom type classes

Lists and Recursion
Handle multiple proposals and votes

Traverse or transform data without loops

IO and the Real World
Accept user input

Simulate voting, show results

Interact with time and deadlines

Monads (Optional for advanced users)
Handle sequencing and side effects (e.g., logging, state)

Use Maybe, Either, or IO to manage error-prone logic

ğŸ’¡ By the End...
You'll understand core Haskell concepts and how to apply them to build real, blockchain-inspired systems â€” all without needing actual smart contract deployment.
